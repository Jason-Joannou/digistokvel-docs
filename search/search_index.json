{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the DigiStokvel Documentation","text":""},{"location":"#project-overview","title":"Project Overview","text":""},{"location":"#business-context","title":"Business Context","text":"<p>A stokvel is a traditional savings scheme practiced in South Africa, where a group of people agrees to contribute a fixed amount of money to a common pool on a regular basis. This pool is then used for a common objective, such as savings, investments, or purchasing goods. The stokvel sector in South Africa is substantial, with over 810,000 active stokvels comprising 11 million members and managing around R50 billion annually. The primary objective of this project is to design and develop a platform that digitizes stokvels using the Interledger Protocol (ILP) Open Payments standard. The platform aims to enhance financial inclusion by being accessible through a low-tech interface, specifically a WhatsApp chatbot. This approach ensures that even users with basic mobile phones can participate in the digital economy.</p>"},{"location":"#problems-and-opportunities","title":"Problems and Opportunities","text":"<p>Problems:</p> <ul> <li>Traditional stokvels often rely on physical meetings and manual record-keeping, making the process time-consuming and prone to errors.</li> <li>Limited access to formal banking services for many stokvel members, which restricts their ability to participate in digital financial services.</li> <li>High transaction costs associated with traditional banking solutions can be a barrier for low-income individuals.</li> </ul> <p>Opportunities:</p> <ul> <li>Leveraging WhatsApp, a widely used communication tool in South Africa, provides a low-cost and familiar interface for users.</li> <li>Using the ILP Open Payments standard allows for interoperability across different financial systems, facilitating easier transfers between users and other financial services.</li> <li>A digital platform can improve transparency, security, and ease of managing contributions and payouts in stokvels, enhancing trust among members.</li> </ul>"},{"location":"#vision","title":"Vision","text":"<p>The vision of the DigiStokvel project is to transform traditional stokvels into a digitally inclusive financial platform, making it easier for South Africans to save, invest, and build community wealth using familiar, low-cost tools like WhatsApp. By providing an accessible interface, DigiStokvel aims to bridge the gap between informal saving groups and the formal digital economy.</p>"},{"location":"#why-is-the-project-important","title":"Why is the project important","text":"<p>This project addresses a critical need for financial inclusion in South Africa, where many people lack access to formal banking services but have mobile connectivity. By digitizing stokvels, the project aims to:</p> <ul> <li>Reduce reliance on cash transactions, increasing security for stokvel participants.</li> <li>Make financial management more efficient and transparent.</li> <li>Provide a platform for members to access additional financial services, such as loans or insurance, through integrations with digital wallets.</li> <li>Empower communities to participate in the digital economy, supporting economic resilience and growth.</li> </ul>"},{"location":"components/database/","title":"Database","text":""},{"location":"components/database/#introduction","title":"Introduction","text":"<p>This project utilizes a SQLite database to build and manage data storage, focusing on scalability and flexibility. The design ensures efficient data handling for stokvel members, transactions, contributions, and payouts.</p>"},{"location":"components/database/#design-overview","title":"Design Overview","text":"<p>While foreign key relationships were defined between various tables to maintain logical data structures, these relationships are not currently enforced by SQLite. This is a limitation of the existing design, and future updates will aim to implement foreign key enforcement to ensure referential integrity across the system.</p>"},{"location":"components/database/#foreign-key-relationships","title":"Foreign Key Relationships","text":"<p>Although foreign key relationships were set up in the table design, they are not enforced at the database level. Enforcing these relationships in future iterations will be essential to prevent orphaned records and to maintain the integrity of relationships between entities (e.g., USERS, STOKVELS, TRANSACTIONS). This step will enhance the data reliability as the system continues to develop.</p>"},{"location":"components/database/#tables-and-relationships","title":"Tables and Relationships","text":"<p>The entity diagram below provides a visual representation of the database structure and the relationships between different tables. It highlights how various entities (tables) are interconnected through foreign key relationships, ensuring that data integrity and logical associations are maintained throughout the system.</p> <p>Each table in the diagram represents a specific entity, such as Users, Stokvels, or Transactions, with lines connecting these tables to illustrate their relationships. For example, the STOKVEL_MEMBERS table links users to specific stokvels by associating user IDs with stokvel IDs, demonstrating a many-to-many relationship.</p> <p>By understanding this diagram, you can see how the data flows and interacts across the system, which is crucial for ensuring efficient data management and integrity. This visual overview helps to quickly identify key components and how they connect, making it easier to navigate and understand the database's design.</p> <p></p>"},{"location":"components/express/","title":"Express","text":""},{"location":"components/express/#express-overview","title":"Express Overview","text":"<p>Express is a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications. It is designed to be simple yet powerful, allowing developers to build web servers and APIs efficiently. Express is particularly well-suited for creating RESTful APIs due to its lightweight structure and middleware capabilities.</p>"},{"location":"components/express/#why-express","title":"Why Express?","text":"<p>We chose Express for the DigiStokvel system to handle communication with the Interledger Protocol (ILP) Open Payments API. Express provides a straightforward way to build RESTful services, enabling us to manage complex payment interactions such as creating grants, handling incoming and outgoing payments, and generating quotes. Its asynchronous nature and middleware support make it ideal for integrating with external APIs, allowing us to streamline the payment processes and enhance the financial aspects of DigiStokvel.</p>"},{"location":"components/express/#core-features","title":"Core Features","text":"<p>The DigiStokvel Express app provides several key features:</p> <ul> <li>Grant Management: Facilitates the creation of grants to authorize access to different parts of the payment system.</li> <li>Incoming and Outgoing Payments: Manages payments to and from users, enabling seamless transactions between participants.</li> <li>Quotes Generation: Supports the creation of quotes to estimate costs for specific payment operations, helping users understand transaction fees before proceeding.</li> <li>Integration with ILP Open Payments: Provides a seamless interface to communicate with the ILP Open Payments API, ensuring secure and efficient payment handling.</li> </ul>"},{"location":"components/express/#endpoints-in-express","title":"Endpoints in Express","text":"<p>For a detailed list of the endpoints available in the DigiStokvel Express app, please refer to our API documentation. The documentation provides comprehensive details on request formats, response structures, and how to interact with each of the Express app\u2019s endpoints. You can access the complete list of endpoints by visiting the Express API Documentation.</p>"},{"location":"components/flask/","title":"Flask","text":""},{"location":"components/flask/#flask-overview","title":"Flask Overview","text":"<p>Flask is a lightweight, micro web framework for Python that is easy to set up and use. It allows developers to create web applications quickly and efficiently by providing essential tools and flexibility. Flask is particularly well-suited for projects where simplicity and modularity are important.</p>"},{"location":"components/flask/#why-flask","title":"Why Flask?","text":"<p>We chose Flask for the DigiStokvel system because of its lightweight architecture, ease of use, and flexibility. Flask allows us to build a scalable backend that can easily handle our needs, including handling API requests, managing data, and integrating with other services like WhatsApp and mobile money solutions.\\</p>"},{"location":"components/flask/#core-features","title":"Core Features","text":"<p>The DigiStokvel Flask backend provides several key features:</p> <ul> <li>User Registration and Authentication: Securely manage user registration, login, and authentication.</li> <li>Stokvel Management: Create, join, and manage stokvel groups.</li> <li>Automated Contributions and Payouts: Schedule and automate contributions and payouts.</li> <li>Integration with WhatsApp: Interact with the system through a WhatsApp chatbot for ease of use.</li> </ul>"},{"location":"components/flask/#endpoints-in-flask","title":"Endpoints in Flask","text":"<p>For a detailed list of the endpoints available in the DigiStokvel system, please refer to our API documentation, which is automatically generated by Swagger UI. You can access the complete list of endpoints, request formats, and responses by visiting the API Documentation.</p>"},{"location":"components/flask_templates/","title":"Why We Use Flask Templates","text":"<p>The use of Flask templates allows us to handle more complex user interactions that would be challenging to manage solely through the WhatsApp interface. While WhatsApp is an effective tool for simple, text-based communication and quick actions, it has limitations when dealing with forms that require multiple fields, user input validation, and more intricate user experiences. Here are a few key reasons:</p> <p>Complex User Inputs:</p> <ul> <li>Forms with Multiple Fields: Managing complex forms, such as updating user details or editing a stokvel's information, is more intuitive and streamlined through a web-based interface. Flask templates enable us to build forms that can include various input types, offer field validation, and provide detailed feedback, which would be cumbersome through a chat interface.</li> <li>Data Validation: Flask allows for real-time data validation, ensuring users receive immediate feedback if they enter invalid information. On WhatsApp, this process would be less fluid, requiring multiple back-and-forth messages to correct user input errors.</li> </ul> <p>Enhanced User Experience:</p> <ul> <li>Visual Feedback and Structure: Unlike WhatsApp, which relies purely on text and simple buttons, a web interface built with Flask templates can provide a richer experience with visual cues, structured forms, and a more intuitive layout. This improves the user experience by guiding users through processes like updating details or managing group settings.</li> <li>Security: Complex actions, such as updating passwords, are best handled through a secure web environment that can properly encrypt and manage user credentials. Flask templates allow for the secure handling of sensitive data inputs, ensuring a safer interaction compared to a more constrained platform like WhatsApp.</li> </ul> <p>Integration with Backend Logic:</p> <ul> <li>Direct Integration: Flask templates can directly interact with backend systems, making it easier to perform actions like form submissions, data processing, and user authentication. This integration streamlines the user experience, ensuring that inputs are processed quickly and accurately without the need for multiple steps.</li> </ul> <p>By using Flask templates, we can provide users with an enhanced, efficient, and secure way to perform complex tasks that go beyond what is feasible within a simple messaging app. This combination of a rich web interface for more intricate interactions and WhatsApp for quick and straightforward communication creates a balanced user experience, making the DigiStokvel platform both versatile and user-friendly.</p>"},{"location":"components/flask_templates/#onboarding-template","title":"Onboarding Template","text":"<p>The <code>onboarding_template</code> page serves as a guide for new users to help them sign up and set up their accounts. It collects basic information like name, email, and password and may offer additional options to customize the user experience.</p> <p>Data Captured:</p> <ul> <li>Full Name: A required field to capture the user's full name, which will be used to personalize the account and communication.</li> <li>Email Address: A required field to capture the user's email, which must follow a valid email format. The email is used for communication and account management.</li> <li>Password: A required field for account security. Password complexity rules may be enforced to ensure strong security.</li> <li>Preference Settings: Optional fields that allow the user to customize their experience (e.g., notification settings, group suggestions).</li> </ul> <p>Why the Onboarding Template page is designed so: Onboarding is critical for user retention and ensuring a smooth first experience. By guiding new users through account setup, the page ensures that users can easily get started with the system. It simplifies the sign-up process while capturing essential information needed for creating an account. The optional customization settings enhance the user experience by tailoring the platform to the user's preferences right from the start.</p> <p>Endpoints in Onboarding Template: POST /onboarding:</p> <ul> <li>The form data is sent to the backend (<code>onboarding.py</code>), where it is validated for accuracy and completeness.</li> <li>The backend checks for duplicate emails and verifies that the password meets the security requirements.</li> <li>If the validation is successful, the user's account is created in the database, and they are logged into the system.</li> <li>If there are any issues, such as a duplicate email or password weakness, appropriate error messages are displayed to guide the user in fixing the problem.</li> </ul> <p></p>"},{"location":"components/flask_templates/#stokvel-creation-template","title":"Stokvel Creation Template","text":"<p>The <code>stokvel_creation_template</code> page allows users to create a new stokvel group by providing basic details such as the group's name, its purpose, and the initial list of members. The page is designed to streamline the process of starting a stokvel.</p> <p>Data Captured:</p> <ul> <li>Group Name: A required field that captures the name of the new stokvel group.</li> <li>Purpose: A description field that outlines the purpose or goal of the group. This helps new members understand what the group is about.</li> <li>Initial Members: A list of people to be invited or added as founding members of the stokvel.</li> </ul> <p>Why the Stokvel Creation Template page is designed so: This page is designed to encourage users to create new stokvels by providing a simple and straightforward process. Group creation needs to be intuitive to lower the barrier for entry, and the page achieves this by minimizing the number of required fields while still capturing essential details. The ability to invite or add initial members during creation also fosters early group collaboration.</p> <p>Endpoints in Stokvel Creation Template: POST /create_stokvel:</p> <ul> <li>The form data is processed by <code>create_stokvel.py</code>, where the backend validates the group name to ensure uniqueness.</li> <li>The backend also ensures that required fields (e.g., group name and purpose) are filled out correctly.</li> <li>If the validation is successful, the new stokvel is created in the database, and the initial members are notified of their inclusion.</li> <li>If there are any issues, such as a duplicate group name, an error message is returned to the user for correction.</li> </ul> <p></p>"},{"location":"components/flask_templates/#joining-template","title":"Joining Template","text":"<p>The <code>joining_template</code> page allows users to submit a request to join an existing stokvel. The page collects the user's basic information and, optionally, a message explaining why they want to join the group.</p> <p>Data Captured:</p> <ul> <li>User Information: The user's name and email address.</li> <li>Reason for Joining: An optional field where the user can explain their motivation for joining the group. This is particularly useful for stokvels that have specific membership criteria.</li> </ul> <p>Why the Joining Template page is designed so: This page formalizes the process of joining a stokvel, ensuring that administrators receive all the necessary information to make informed decisions about membership. The optional reason-for-joining field helps administrators understand the user's motivations and decide whether they are a good fit for the group.</p> <p>Endpoints in Joining Template: POST /join_stokvel:</p> <ul> <li>The form data is processed by <code>join_stokvel.py</code>, which submits the user's request to the stokvel administrator.</li> <li>The system checks for potential issues (e.g., duplicate requests) before submitting the application.</li> <li>Upon successful submission, the user is notified that their request has been sent. The stokvel admin will then review the application and decide whether to accept or reject it.</li> </ul> <p></p>"},{"location":"components/flask_templates/#approve-applications","title":"Approve Applications","text":"<p>The <code>approve_applications</code> page is designed for stokvel administrators to manage membership requests. Administrators can view pending applications and either approve or reject them based on the details provided by the applicants.</p> <p>Data Captured: - Pending Applications: A list of pending membership requests is displayed, including each applicant's name, email, and reason for joining (if provided).</p> <p>Why the Approve Applications page is designed so: This page is essential for stokvel management. It provides a simple and intuitive interface for administrators to view and manage applications, ensuring that the group's membership is carefully controlled. By reviewing the reasons for joining, administrators can maintain the integrity of the group and ensure that new members align with the group's purpose.</p> <p>Endpoints in Approve Applications: POST /approve_application:</p> <ul> <li>The administrator's decision (approve or reject) is sent to <code>approve_applications.py</code>, where the backend updates the status of the application in the database.</li> <li>If the application is approved, the user is notified and added to the group. If rejected, the user is informed of the decision.</li> <li>The page may also allow administrators to leave a note explaining their decision, particularly if the application is rejected.</li> </ul> <p></p>"},{"location":"components/flask_templates/#action-success-template","title":"Action Success Template","text":"<p>The <code>action_success_template</code> page is a generic confirmation page that informs users that their requested action has been successfully completed. It is commonly used after form submissions or updates, providing a clear indication that the user's request was processed without errors.</p> <p>Data Captured: - No specific data is captured on this page. It simply displays a success message.</p> <p>Why the Action Success Template page is designed so: Feedback is crucial for user experience. After completing an action (e.g., submitting a form or updating a profile), users need to know that their request was successful. The <code>action_success_template</code> provides this confirmation, ensuring that users are aware that their action was processed as expected.</p> <p>Endpoints in Action Success Template: GET /action_success:</p> <ul> <li>This endpoint displays the success message after a user completes a specific action, such as submitting a form or making an update. It is designed to provide positive feedback and closure to the user's interaction.</li> </ul> <p></p>"},{"location":"components/flask_templates/#action-failed-template","title":"Action Failed Template","text":"<p>The <code>action_failed_template</code> page notifies users that an action they attempted has failed, usually due to a validation error or system issue. This page is designed to help users understand what went wrong and how they can correct it.</p> <p>Data Captured:</p> <ul> <li>No specific data is captured on this page. It simply displays an error message with guidance on how to resolve the issue.</li> </ul> <p>Why the Action Failed Template page is designed so:</p> <ul> <li>When something goes wrong, users need clear feedback to understand the problem and how to fix it. The <code>action_failed_template</code> page provides this feedback, helping users correct errors and retry their actions. It improves user experience by providing clear guidance on next steps.</li> </ul> <p>Endpoints in Action Failed Template: GET /action_failed:</p> <ul> <li>This endpoint displays an error message when the user's action fails. It could be triggered by form validation failures, incorrect login attempts, or issues processing a request. The page offers guidance on how the user can resolve the issue or retry the action.</li> </ul> <p></p>"},{"location":"components/function_app/","title":"Function App","text":""},{"location":"components/function_app/#function-apps-overview","title":"Function Apps Overview","text":"<p>In the DigiStokvel system, function apps play a critical role in automating the financial operations, specifically managing payouts and contributions. These function apps are scheduled to run daily, ensuring that all scheduled payments are processed on time without manual intervention. By using function apps, we achieve a high level of efficiency and reliability in managing the flow of funds within each stokvel.</p>"},{"location":"components/function_app/#purpose-of-function-apps","title":"Purpose of Function Apps","text":"<p>The function apps are designed to handle the core financial operations of DigiStokvel, focusing on two main engines:</p> <p>Payouts Engine:</p> <ul> <li>Responsible for executing scheduled payouts to stokvel members. This ensures that members receive their payments automatically based on the agreed payout schedules without requiring administrators to manually initiate the process.</li> <li>The function app checks the payout schedule daily and processes any payments that are due. It retrieves the relevant details (such as the amount and recipient information) and initiates the transfer, ensuring timely and accurate disbursement of funds.</li> </ul> <p>Contributions Engine:</p> <ul> <li>Manages the recurring contributions from stokvel members. Members\u2019 contributions are essential for maintaining the financial health of the stokvel, and the contributions engine ensures that these payments are processed smoothly.</li> <li>The function app runs daily to check if any members are due to make a contribution on that day. If there are scheduled contributions, the app initiates the payment process, debiting the members' accounts and crediting the stokvel's funds.</li> </ul>"},{"location":"components/function_app/#how-function-apps-work","title":"How Function Apps Work","text":"<p>Daily Schedule:</p> <ul> <li>The function apps are scheduled to run automatically every day. This setup ensures that the system does not miss any scheduled payouts or contributions, maintaining consistency and trust among stokvel members.</li> <li>Each day, the function apps check the database for any scheduled payments and determine if a payout or contribution needs to be processed.</li> </ul> <p>Automated Payment Processing:</p> <ul> <li>When a payment (either payout or contribution) is due, the function app retrieves the necessary details, such as the amount, recipient, and payment method.</li> <li>The app then initiates the payment through the DigiStokvel system\u2019s integrated payment processing service, ensuring that funds are transferred securely and efficiently.</li> <li>After the payment is processed, the app updates the database to reflect the transaction, marking it as completed and sending any necessary notifications to the stakeholders.</li> </ul> <p>Error Handling and Notifications:</p> <ul> <li>The function apps are equipped with error handling mechanisms to manage any issues that may arise during payment processing (e.g., insufficient funds, network failures).</li> <li>If an error occurs, the app logs the issue and attempts to retry the payment if possible. Additionally, administrators are notified so they can take any necessary actions to resolve the issue.</li> </ul>"},{"location":"components/function_app/#benefits-of-using-function-apps","title":"Benefits of Using Function Apps","text":"<ul> <li>Automation: By automating the process of managing payouts and contributions, function apps reduce the need for manual intervention, saving time and reducing the risk of errors.</li> <li>Scalability: Function apps can handle a high volume of payments, making them suitable for stokvels of all sizes. As the number of members grows, the system can scale to accommodate the increased demand without significant changes to the infrastructure.</li> <li>Reliability: Running the function apps on a daily schedule ensures that no scheduled payment is missed, maintaining the trust and consistency that are essential in a financial platform like DigiStokvel.</li> <li>Efficiency: Automated processing ensures that all payments are handled quickly and accurately, allowing stokvel administrators to focus on other important tasks rather than manually managing payouts and contributions.</li> </ul>"},{"location":"components/function_app/#technical-details","title":"Technical Details","text":"<p>The function apps are deployed on a cloud-based platform, ensuring high availability and reliability. They are configured to run daily using cron schedules, and each function is designed to be lightweight and efficient, focusing solely on its core task of processing payments.</p> <p>By leveraging these function apps, DigiStokvel ensures that its financial operations run smoothly, providing users with a seamless and automated experience. This setup allows stokvel members and administrators to have confidence in the system, knowing that their payouts and contributions are managed accurately and on schedule.</p>"},{"location":"components/overview/","title":"Overview","text":""},{"location":"components/overview/#components-overview","title":"Components Overview","text":"<p>The DigiStokvel project is built using a modular architecture, leveraging various components to handle specific functions such as database management, backend frameworks, and automated financial operations. This overview provides a detailed look at the core components that form the foundation of the DigiStokvel system.</p>"},{"location":"components/overview/#database","title":"Database","text":"<p>The DigiStokvel system uses SQLite for its database, which stores and manages key data related to stokvels, users, transactions, and contributions. Although foreign key relationships have been defined between tables, they are not enforced by SQLite in the current design. Future iterations will enhance data integrity by enforcing these relationships.</p> <ul> <li>Key Features:</li> <li>Storage for users, stokvels, transactions, and payouts.</li> <li>Efficient handling of stokvel member data, contributions, and financial operations.</li> <li>Future-proof design for scalability and referential integrity.</li> </ul> <p>For a more detailed description of the database design, including table structures and relationships, refer to the Database Overview.</p>"},{"location":"components/overview/#express","title":"Express","text":"<p>Express is used as the core framework for DigiStokvel\u2019s backend services, specifically for handling communication with the Interledger Protocol (ILP). Express is lightweight yet powerful, enabling the system to manage grants, incoming and outgoing payments, and quotes generation with the ILP Open Payments API.</p> <ul> <li>Core Features:</li> <li>RESTful API services to interact with payment systems.</li> <li>Integration with ILP for managing grants and secure payment transactions.</li> <li>Asynchronous processing to handle multiple user requests efficiently.</li> </ul> <p>For more information on how Express is used in the DigiStokvel project, visit the Express Overview.</p>"},{"location":"components/overview/#flask-templates","title":"Flask Templates","text":"<p>The Flask framework is utilized to build web-based user interfaces that complement WhatsApp-based interactions. While WhatsApp is the primary communication channel for simple text commands, more complex tasks like form submissions and detailed user inputs are handled using Flask templates.</p> <ul> <li>Key Use Cases:</li> <li>Complex forms for user onboarding, stokvel creation, and membership management.</li> <li>Secure handling of sensitive information, such as user credentials and stokvel settings.</li> <li>Enhanced user experience through rich visual feedback and structured forms.</li> </ul> <p>To learn more about why Flask templates are integrated into the system, refer to the Flask Template Overview.</p>"},{"location":"components/overview/#flask-backend","title":"Flask Backend","text":"<p>The Flask backend serves as the backbone of the DigiStokvel system, handling core operations such as user registration, stokvel management, and integration with payment services like MTN MoMo and WhatsApp.</p> <ul> <li>Key Features:</li> <li>User authentication and management.</li> <li>Stokvel creation, contribution tracking, and payouts.</li> <li>Automated financial operations integrated with WhatsApp chatbot for user convenience.</li> </ul> <p>For further details about the endpoints and features provided by the Flask backend, see the Flask Overview.</p>"},{"location":"components/overview/#function-apps","title":"Function Apps","text":"<p>Function apps automate the core financial operations within the DigiStokvel system, specifically for handling scheduled contributions and payouts. These apps run daily, ensuring that all financial activities are processed without manual intervention.</p> <ul> <li>Payouts Engine: Automatically handles the disbursement of funds to stokvel members based on the predefined payout schedules.</li> <li>Contributions Engine: Automates the collection of recurring contributions from stokvel members, ensuring the financial stability of the group.</li> </ul> <p>The function apps are critical for ensuring the efficiency and reliability of DigiStokvel's automated financial workflows. To explore how these apps work, visit the Function Apps Overview.</p>"},{"location":"devops/agile/","title":"Agile Workflow","text":""},{"location":"devops/agile/#sprint-workflow","title":"Sprint Workflow","text":"<p>Our project follows an Agile development methodology, with work organized into iterative sprints. Each sprint is a time-boxed period, typically lasting a week, during which specific tasks and goals are completed. This approach allows for continuous delivery of incremental improvements and ensures that we can adapt to changes and feedback quickly.</p>"},{"location":"devops/agile/#sprint-planning","title":"Sprint Planning","text":"<p>Defining Sprint Goals</p> <ul> <li>At the beginning of each sprint, the team holds a sprint planning meeting to define the objectives for the upcoming sprint. These objectives are typically derived from the product backlog, which is a prioritized list of features, enhancements, and bug fixes.</li> <li>The team discusses and agrees on the most critical items to focus on, ensuring that the sprint goal aligns with the overall project objectives.</li> </ul> <p>Task Breakdown and Estimation</p> <ul> <li>The selected sprint tasks are broken down into smaller, manageable units of work, often referred to as user stories or tasks. Each task is estimated in terms of effort, usually in story points or hours.</li> <li>The team collaboratively estimates the complexity and effort required for each task, considering factors like dependencies, risks, and potential challenges.</li> </ul> <p>Assigning Tasks</p> <ul> <li>Once tasks are defined and estimated, they are assigned to team members based on their expertise, availability, and workload. Task assignments are flexible and can be adjusted as the sprint progresses.</li> </ul>"},{"location":"devops/agile/#sprint-execution","title":"Sprint Execution","text":"<p>Daily Standups</p> <ul> <li>Throughout the sprint, the team holds daily standup meetings, also known as daily scrums. These brief meetings allow each team member to share what they accomplished the previous day, what they plan to work on today, and any blockers or challenges they are facing.</li> <li>Daily standups foster communication, transparency, and collaboration among team members, ensuring that everyone is aligned and aware of the sprint's progress.</li> </ul> <p>Task Progress and Updates</p> <ul> <li>As tasks are worked on, team members update the status in the project management tool (Azure Boards). This helps track progress, identify bottlenecks, and ensure that the sprint stays on track.</li> <li>Regular check-ins and communication are encouraged to address any issues promptly and to provide support where needed.</li> </ul>"},{"location":"devops/agile/#sprint-review-and-retrospective","title":"Sprint Review and Retrospective","text":"<p>Sprint Review</p> <ul> <li>At the end of each sprint, the team conducts a sprint review meeting. During this meeting, completed work is demonstrated to stakeholders, and feedback is gathered. This review helps ensure that the deliverables meet the expected quality and functionality.</li> <li>Stakeholders provide input, and any new requirements or changes are discussed and added to the product backlog if necessary.</li> </ul> <p>Sprint Retrospective</p> <ul> <li>Following the sprint review, the team holds a sprint retrospective meeting. This meeting is an opportunity to reflect on the sprint, discussing what went well, what could have been improved, and what actions can be taken to enhance future sprints.</li> <li>The retrospective is a key aspect of continuous improvement, allowing the team to learn from each sprint and make adjustments to their process, tools, or communication strategies.</li> </ul>"},{"location":"devops/agile/#benefits-of-sprints","title":"Benefits of Sprints","text":"<ul> <li>Flexibility: Sprints allow the team to adapt to changes quickly, incorporating new requirements or feedback without disrupting the overall project timeline.</li> <li>Focus: By concentrating on a specific set of tasks each sprint, the team can deliver high-quality work and maintain a steady pace of progress.</li> <li>Continuous Feedback: Regular reviews and retrospectives ensure that the team receives continuous feedback, enabling them to make iterative improvements and deliver a product that meets stakeholder expectations.</li> </ul>"},{"location":"devops/docker/","title":"Docker","text":""},{"location":"devops/docker/#docker-overview","title":"Docker Overview","text":"<p>Docker is an open-source platform that enables developers to automate the deployment of applications inside lightweight, portable containers. Containers bundle the application code with its dependencies and environment, ensuring consistency across different environments, such as development, testing, and production. By using Docker, we can create reproducible and isolated environments that simplify the deployment process and enhance scalability.</p>"},{"location":"devops/docker/#api-example","title":"API Example","text":"<p>In our project, we have utilized Docker to containerize the API, making it easy to deploy and manage across various environments. Below is the Dockerfile used to create the container image for our API:</p> <pre><code># Use the official Python image from the Docker Hub\nFROM python:3.9-slim\n\n# Set the working directory\nWORKDIR /app\n\n# Copy only the requirements file from the root\nCOPY ../requirements.txt .\n\n# Install the required packages\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Copy specific directories needed for service1\nCOPY ../api ./api\nCOPY ../database ./database\nCOPY ../whatsapp_utils ./whatsapp_utils\n\n# Expose the port the app runs on\nEXPOSE 80\n\n# Define the command to run the application\nCMD [\"gunicorn\", \"-w\", \"4\", \"-b\", \"0.0.0.0:80\", \"api.app:app\"]\n</code></pre> <p>This Dockerfile begins by pulling the official Python 3.9-slim image from Docker Hub, providing a lightweight base for our API. The working directory is set to <code>/app</code>, where the application code will reside. The <code>requirements.txt</code> file, containing the necessary dependencies, is copied into the container, and the required packages are installed using <code>pip</code>.</p> <p>After the dependencies are installed, the rest of the application code is copied into the container. The <code>EXPOSE</code> instruction specifies that the container listens on port 80. Finally, the <code>CMD</code> instruction defines the command to start the API using Gunicorn, specifying that it should run on all available network interfaces (<code>0.0.0.0</code>) on port 80.</p> <p>This setup ensures that our API is encapsulated in a consistent environment, ready for deployment across different stages of development and production.</p>"},{"location":"devops/docker/#docker-workflow","title":"Docker Workflow","text":"<p>To push our Docker image to Azure Container Registry (ACR), we follow these steps:</p> <p>Build the Docker Image</p> <p>First, we build the Docker image using the <code>docker build</code> command. This command reads the <code>Dockerfile</code> in the current directory and creates an image based on its instructions.</p> <pre><code>docker build -t &lt;image-name&gt;:&lt;tag&gt; .\n</code></pre> <ul> <li><code>&lt;image-name&gt;</code>: The name we want to assign to the Docker image.</li> <li><code>&lt;tag&gt;</code>: The version tag for the image (e.g., <code>v1.0.0</code>).</li> </ul> <p>Login to Azure Container Registry</p> <p>Authenticate Docker with our Azure Container Registry using the <code>az acr login</code> command.</p> <pre><code>az acr login --name &lt;acr-name&gt;\n</code></pre> <p>Alternatively, we can log in directly using Docker:</p> <pre><code>docker login &lt;acr-name&gt;.azurecr.io\n</code></pre> <ul> <li><code>&lt;acr-name&gt;</code>: This is the name of our Azure Container Registry.</li> <li>We are prompted to enter our username and password, which can be obtained from the Azure portal.</li> </ul> <p>Tag the Docker Image</p> <p>Tag the Docker image with the ACR repository URL to prepare it for pushing. We replace <code>&lt;acr-name&gt;</code>, <code>&lt;image-name&gt;</code>, and <code>&lt;tag&gt;</code> with our specific details.</p> <pre><code>docker tag &lt;image-name&gt;:&lt;tag&gt; &lt;acr-name&gt;.azurecr.io/&lt;image-name&gt;:&lt;tag&gt;\n</code></pre> <ul> <li><code>&lt;acr-name&gt;</code>: The name of our Azure Container Registry.</li> <li><code>&lt;image-name&gt;</code>: The name of our Docker image.</li> <li><code>&lt;tag&gt;</code>: The version tag for the image.</li> </ul> <p>Push the Docker Image to ACR</p> <p>Push the tagged Docker image to our Azure Container Registry using the <code>docker push</code> command.</p> <pre><code>docker push &lt;acr-name&gt;.azurecr.io/&lt;image-name&gt;:&lt;tag&gt;\n</code></pre> <ul> <li><code>&lt;acr-name&gt;</code>: The name of our Azure Container Registry.</li> <li><code>&lt;image-name&gt;</code>: The name of our Docker image.</li> <li><code>&lt;tag&gt;</code>: The version tag for the image.</li> </ul> <p>Verify the Image</p> <p>After pushing, we can verify that the image has been successfully uploaded to ACR by listing the images in the registry.</p> <pre><code>az acr repository list --name &lt;acr-name&gt; --output table\n</code></pre> <ul> <li><code>&lt;acr-name&gt;</code>: The name of our Azure Container Registry.</li> </ul> <p>This workflow ensures that our Docker image is built, tagged, and pushed to Azure Container Registry, making it available for deployment in our cloud environment.</p>"},{"location":"devops/git/","title":"Git Management","text":""},{"location":"devops/git/#overview","title":"Overview","text":"<p>Git is a distributed version control system that allows multiple developers to work on a project simultaneously without overwriting each other's changes. It keeps track of every modification to the project's files, enabling you to revert to previous versions if necessary. Git is essential for collaborative software development as it provides a structured way to manage and merge contributions from different team members, ensuring the project's integrity.</p> <p>GitHub is an online platform that hosts Git repositories, offering a web-based interface for managing Git projects. It facilitates collaboration by allowing developers to share their repositories, review code, track issues, and deploy applications. GitHub also provides tools for continuous integration and deployment, making it an invaluable resource for modern software development.</p> <p>Using Git and GitHub in coding projects ensures a well-organized workflow, where changes are documented, collaboration is streamlined, and the project history is preserved, which is crucial for both development and maintenance.</p>"},{"location":"devops/git/#git-management","title":"Git Management","text":"<p>Effective Git management involves several key practices to maintain a clean and efficient workflow. These include:</p> <ul> <li> <p>Branching Strategy: Implementing a branching strategy (such as GitFlow or Feature Branching) ensures that development, testing, and deployment processes are well-organized. For example, keeping the main branch stable while using feature branches for new developments helps maintain the project's integrity.</p> </li> <li> <p>Commit Practices: Writing clear and concise commit messages, and committing changes frequently with meaningful descriptions, makes it easier to understand the project's history and roll back changes if needed.</p> </li> <li> <p>Merge and Pull Requests: Regularly merging branches and using pull requests to review and discuss changes before integrating them into the main branch is essential for maintaining code quality and preventing conflicts.</p> </li> </ul> <p>By adhering to these Git management practices, teams can ensure that their project remains organized, scalable, and easy to maintain throughout its lifecycle.</p>"},{"location":"devops/git/#general-git-management","title":"General Git Management","text":"<p>The repository exists of multiple branches that have been created for testing, bug fixes, and individual development. This allows the team to develop in parallel. The repository also has a main branch and a main staging branch. Both of these branches are considered \"production\" ready branches. The staging branch is a buffer for the commits before they are moved into the main branch.</p> <p>The general git workflow for the backend system can be analyzed in the git workflow diagram but on a high level the workflow is as follows:</p> <ul> <li>2 protected branches ( main, main_staging )</li> <li>These branches have branch rules that restrict commits being pushed without a PR.</li> <li>When creating a PR into the protected branch, the commit will run  through a CI pipeline and automatically formats the code, suggests  changes and checks for errors through static type checking and pytests</li> <li>If an error occurs during the CI pipeline, the PR is rejected until the issues are fixed.</li> <li>Developers can commit normally to any other branches</li> </ul>"},{"location":"devops/git/#git-workflow-visualized","title":"Git Workflow Visualized","text":"<p>The image above illustrates the general workflow for committing changes to the repository. Starting from the green circle, the process unfolds as follows:</p> <ul> <li>A developer makes a commit.</li> <li>Is the branch a protected branch?<ul> <li>If not protected, the developer can continue committing directly to the branch.</li> <li>If protected, the commit cannot be pushed directly; a pull request (PR) is required.</li> </ul> </li> <li>The developer must create a PR if the branch is protected.</li> <li>Once the PR is created, it is automatically run through a Continuous Integration (CI) pipeline that includes code tests and linting checks.<ul> <li>If the PR fails the CI checks, the developer is notified of the failure and must address the issues, starting the process again from the green circle.</li> </ul> </li> <li>If the PR passes the CI checks, it proceeds to the review stage, where it must be approved by at least two developers.<ul> <li>If any reviewer rejects the PR, the developer must resolve the issues and restart the process from the green circle.</li> </ul> </li> <li>If all reviewers approve the PR, the code is merged into the protected branch.</li> </ul>"},{"location":"devops/git/#ci-pipeline","title":"CI Pipeline","text":"<p>The Continuous Integration (CI) pipeline is a crucial part of our development process, ensuring that code changes meet our project's quality standards before they are merged into the main branch. The CI pipeline is automatically triggered when a developer creates a pull request targeting the <code>main</code> branch. The pipeline consists of several stages:</p> <p>The pipeline starts by checking out the code and setting up a Python 3.9 environment. It then installs linting tools like Flake8, Pylint, and MyPy.</p> <ul> <li>Flake8 is used to ensure the code adheres to Python coding standards and is free of syntax errors.</li> <li>Pylint provides a more thorough analysis of the code, checking for potential issues such as coding standards violations, errors, and warnings. The pipeline requires a minimum Pylint score of <code>9.7</code> for the linting stage to pass.</li> <li>MyPy checks for type safety, ensuring that the code has correct type annotations and is less prone to type-related bugs.</li> </ul> <p>If the linting process succeeds, the pipeline proceeds to the code formatting stage.</p> <ul> <li>Isort organizes import statements to maintain a clean and consistent order.</li> <li> <p>Black automatically formats the code according to the project's style guidelines. If any formatting changes are required, Black will make these changes, and the pipeline will attempt to commit and push the updated code back to the pull request branch. This ensures that all code merged into the main branch is properly formatted without manual intervention.</p> </li> <li> <p>Automated Code Fixes: During the formatting stage, if Black or Isort detects any required changes, the pipeline commits and pushes these changes back to the pull request branch. This automated process helps maintain consistent code quality by enforcing formatting rules without requiring developers to manually adjust their code.</p> </li> <li> <p>Conditional Execution: The formatting stage runs only if the linting process passes, ensuring that the pipeline does not proceed with code that has linting errors. Additionally, if there are no changes to be made, the pipeline will not attempt to push any updates.</p> </li> </ul> <p>This automated CI pipeline helps maintain high code quality by ensuring that all code is well-structured, adheres to defined standards, and is type-safe. It also streamlines the development process by automatically fixing formatting issues, reducing the effort required by developers to maintain clean and consistent code.</p> <p>Below is the CI YAML configuration that initializes our pipeline:</p> <pre><code>name: CI Pipeline\n\non:\n  pull_request:\n    branches:\n      - main\n\npermissions:\n  contents: write  # Allows pushing changes back to the PR branch\n\njobs:\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Set up Python 3.9\n        uses: actions/setup-python@v4\n        with:\n          python-version: \"3.9\"\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install flake8 pylint mypy\n\n      - name: Run Flake8\n        run: flake8 .\n\n      - name: Run Pylint\n        run: pylint --recursive=y --fail-under=9.7 .\n\n      - name: Run MyPy\n        run: mypy . --install-types --non-interactive\n\n  format:\n    needs: lint\n    if: success()  # Run only if lint job succeeds\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n        with:\n          ref: ${{ github.head_ref }}  # Checkout the PR branch\n\n      - name: Set up Python 3.9\n        uses: actions/setup-python@v4\n        with:\n          python-version: \"3.9\"\n\n      - name: Install formatting tools\n        run: |\n          python -m pip install --upgrade pip\n          pip install black isort\n\n      - name: Run Isort\n        run: isort .\n\n      - name: Run Black\n        run: black .\n\n      - name: Check for formatting changes\n        id: check-diff\n        run: |\n          git diff --exit-code || echo \"Formatting changes detected\"\n          if [ -n \"$(git diff)\" ]; then\n            echo \"changed=true\" &gt;&gt; $GITHUB_ENV\n          else\n            echo \"changed=false\" &gt;&gt; $GITHUB_ENV\n          fi\n\n      - name: Commit formatting changes\n        if: env.changed == 'true'\n        run: |\n          git config user.name \"github-actions\"\n          git config user.email \"github-actions@github.com\"\n          git add .\n          git commit -m \"Auto-format code\" || echo \"No changes to commit\"\n\n      - name: Push formatting changes back to PR branch\n        if: env.changed == 'true'\n        run: |\n          git push origin HEAD:${{ github.head_ref }} || echo \"Failed to push changes\"\n</code></pre>"},{"location":"devops/overview/","title":"Overview","text":""},{"location":"devops/overview/#devops-overview","title":"DevOps Overview","text":"<p>The DevOps strategy for DigiStokvel focuses on delivering a seamless, automated development and deployment process. By leveraging agile methodologies, containerization, and infrastructure as code (IaC) tools, the project ensures that each component is scalable, secure, and consistently deployed across environments. This overview highlights how the team has incorporated modern DevOps practices to enhance collaboration, increase deployment speed, and maintain system reliability.</p>"},{"location":"devops/overview/#key-components-of-the-devops-pipeline","title":"Key Components of the DevOps Pipeline","text":""},{"location":"devops/overview/#agile-workflow","title":"Agile Workflow","text":"<p>DigiStokvel follows an Agile development methodology, with work organized into iterative sprints. This methodology allows the team to release features incrementally, ensuring continuous delivery and the flexibility to adapt to changes quickly.</p> <ul> <li>Sprint Planning: At the beginning of each sprint, goals are defined based on the product backlog. Tasks are estimated and assigned to team members for execution.</li> <li>Sprint Execution: Daily standups facilitate communication and ensure alignment. Tasks are updated in Azure Boards, providing real-time visibility of progress.</li> <li>Sprint Review and Retrospective: The team reviews deliverables with stakeholders, gathers feedback, and reflects on ways to improve future sprints. The agile workflow improves flexibility and responsiveness to feedback, allowing for continuous integration of new features.</li> </ul> <p>For more details on the sprint workflow, visit the Agile Workflow page.</p>"},{"location":"devops/overview/#version-control-and-collaboration","title":"Version Control and Collaboration","text":"<ul> <li>All code is managed using Git with repositories hosted on GitHub. GitHub facilitates version control, code review, and team collaboration, ensuring all changes are tracked efficiently.</li> <li>Branching Strategy: A feature-branch workflow is adopted, where each new feature or bug fix is developed in an isolated branch. After passing code reviews and automated testing, changes are merged into the main branch.</li> <li>The Git Workflow details the full branching strategy for DigiStokvel.</li> </ul>"},{"location":"devops/overview/#continuous-integration-ci","title":"Continuous Integration (CI)","text":"<ul> <li>GitHub Actions is used for continuous integration, triggering automated builds and tests on each code commit. This process ensures the codebase remains stable, with immediate feedback provided on code quality.</li> <li>The CI pipeline integrates unit tests, integration tests, and linting, which run automatically to verify that new changes do not introduce regressions.</li> </ul>"},{"location":"devops/overview/#containerization-with-docker","title":"Containerization with Docker","text":"<p>DigiStokvel uses Docker to containerize the application components, ensuring consistent behavior across development, staging, and production environments.</p> <ul> <li>API Containerization: The API is encapsulated in a Docker container, isolating dependencies and providing an easily replicable deployment setup.</li> <li>The Docker workflow also simplifies environment management, reducing the time required to replicate environments for development or testing.</li> </ul> <p>Refer to the Docker Overview for details on how the DigiStokvel API is containerized.</p>"},{"location":"devops/overview/#infrastructure-as-code-with-terraform","title":"Infrastructure as Code with Terraform","text":"<p>DigiStokvel\u2019s infrastructure is defined using Terraform, an infrastructure-as-code tool that automates the provisioning and management of cloud resources.</p> <ul> <li>Azure Deployment: Terraform is used to provision and manage resources such as Azure Container Instances (ACI) and Azure Container Registry (ACR), ensuring scalability and consistency across deployments.</li> <li>Infrastructure Automation: By defining infrastructure in code, Terraform enables automatic scaling and disaster recovery, as well as easy replication of environments.</li> </ul> <p>For detailed infrastructure definitions, see the Terraform Overview.</p>"},{"location":"devops/overview/#deployment-workflow","title":"Deployment Workflow","text":"<ul> <li>Azure Cloud: DigiStokvel is deployed on Azure, utilizing ACI for containerized workloads and ACR for managing Docker images. This setup provides a robust, scalable environment for running the application.</li> <li>Automated Deployment: The deployment pipeline automates the process from building Docker images to pushing them to ACR and deploying to ACI.</li> </ul>"},{"location":"devops/overview/#documentation-and-collaboration","title":"Documentation and Collaboration","text":"<ul> <li>MkDocs is used to generate and maintain project documentation. The documentation is continuously updated as new features are developed, ensuring transparency and easy access to project information.</li> <li>The Material theme for MkDocs provides a clean and intuitive interface for browsing documentation, and links to API documentation generated by Swagger UI ensure that the project is well-documented for both developers and stakeholders.</li> </ul>"},{"location":"devops/terraform/","title":"Terraform","text":""},{"location":"devops/terraform/#terraform-overview","title":"Terraform Overview","text":"<p>Terraform is an open-source Infrastructure as Code (IaC) tool that allows you to define and provision data center infrastructure using a high-level configuration language. With Terraform, you can manage resources across various cloud providers, such as Azure, AWS, and Google Cloud, in a consistent and repeatable manner.</p> <p>In our project, we have used Terraform to define and manage our infrastructure on Azure. This approach enables us to automate the deployment and management of resources, ensuring that our infrastructure is consistent, scalable, and easily reproducible.</p> <p>For example, below is the Terraform configuration file that outlines our API infrastructure setup:</p> <pre><code># IaC main file\n\n# Define provider\nprovider \"azurerm\" {\n  features {\n\n  }\n  subscription_id = \"secret\"\n\n}\n\n# Define resource group\nresource \"azurerm_resource_group\" \"masters_uct\" {\n  name     = \"Masters-UCT\"\n  location = \"UK South\"\n}\n\n# Define our container registry\nresource \"azurerm_container_registry\" \"acr\" {\n  name                = \"mastersuctacrv1\"\n  resource_group_name = azurerm_resource_group.masters_uct.name\n  location            = azurerm_resource_group.masters_uct.location\n  sku                 = \"Basic\"\n  admin_enabled       = true\n}\n\nresource \"azurerm_container_group\" \"aci_flask_api\" {\n  name                = \"flask-api\"\n  resource_group_name = azurerm_resource_group.masters_uct.name\n  location            = azurerm_resource_group.masters_uct.location\n  os_type             = \"Linux\"\n\n  container {\n    name   = \"flask-api-container\"\n    image  = \"${azurerm_container_registry.acr.login_server}/stokvel_flask_api:v1.0.2\"\n    cpu    = \"1\"\n    memory = \"1.5\"\n\n    environment_variables = {\n      TWILIO_ACCOUNT_SID  = \"secret\"\n      TWILIO_AUTH_TOKEN   = \"secret\"\n      TWILIO_PHONE_NUMBER = \"secret\"\n    }\n\n    ports {\n      port     = 80\n      protocol = \"TCP\"\n    }\n\n  }\n\n  ip_address_type = \"Public\"\n  dns_name_label  = \"stokveldigital\" # Ensure this is a unique DNS name\n  image_registry_credential {\n    server   = azurerm_container_registry.acr.login_server\n    username = azurerm_container_registry.acr.admin_username\n    password = azurerm_container_registry.acr.admin_password\n  }\n\n\n}\n\noutput \"container_registry_login_server\" {\n  value = azurerm_container_registry.acr.login_server\n}\n\noutput \"flask_api_fqdn\" {\n  value = azurerm_container_group.aci_flask_api.fqdn\n}\n</code></pre> <p>This Terraform configuration begins by specifying the Azure provider, ensuring that our deployment targets the correct cloud environment.</p> <ol> <li> <p>Resource Group:</p> <ul> <li>We define a resource group named <code>Masters-UCT</code>, located in the <code>UK South</code> region. This resource group acts as an organizational container for all our related resources.</li> </ul> </li> <li> <p>Azure Container Registry (ACR):</p> <ul> <li>Within this resource group, we create an Azure Container Registry (ACR) named <code>mastersuctacr</code>. This ACR allows us to store and manage Docker container images, with the admin feature enabled for easier access.</li> </ul> </li> <li> <p>Azure Container Instance (ACI):</p> <ul> <li>To deploy our public API, we utilize an Azure Container Instance (ACI) named <code>mastersuctaci</code>. This instance runs a Linux-based container, specifically the <code>fsd-public-api</code> image, which is pulled directly from our ACR. The container is configured with 0.5 CPUs and 1.5 GB of memory, with port 80 open for HTTP traffic.</li> <li>The ACI is assigned a public IP address and is accessible via a DNS name label <code>fsdpublicapi</code>, enabling users to interact with our API.</li> </ul> </li> <li> <p>Outputs:</p> <ul> <li>The configuration outputs the login server URL for the container registry and the fully qualified domain name (FQDN) for the container instance. These outputs provide essential endpoints for managing and accessing our deployed resources.</li> </ul> </li> </ol> <p>This Terraform setup ensures that our infrastructure is consistent, scalable, and easy to manage.</p>"},{"location":"devops/terraform/#terraform-workflow-in-our-project","title":"Terraform Workflow in our Project","text":"<p>To apply changes defined in a Terraform configuration file, we generally follow a series of commands. Here's how they works:</p>"},{"location":"devops/terraform/#terraform-commands","title":"Terraform Commands","text":"<ol> <li> <p><code>terraform init</code>:</p> <ul> <li>Purpose: This command initializes the Terraform working directory. It downloads the necessary provider plugins specified in our configuration file (e.g., <code>azurerm</code> for Azure) and sets up the backend for storing the state file (<code>terraform.tfstate</code>).</li> <li>When to Run: We run this command once after creating or cloning a Terraform configuration. It\u2019s also necessary after adding new providers or modules to the configuration.</li> </ul> </li> <li> <p><code>terraform plan</code>:</p> <ul> <li>Purpose: This command creates an execution plan, showing us what Terraform will do when we apply our changes. It compares the state file with our current configuration to determine what needs to be created, modified, or destroyed.</li> <li>When to Run: We use this command to review the changes before applying them. It\u2019s a good practice to run it every time we make changes to your configuration file.</li> </ul> </li> <li> <p><code>terraform apply</code>:</p> <ul> <li>Purpose: This command applies the changes required to reach the desired state of the configuration, as outlined by the plan. It prompts us to confirm the execution of the changes by typing \"yes\".</li> <li>When to Run: After reviewing the plan, we run this command to apply the changes to your infrastructure.</li> </ul> </li> <li> <p><code>terraform destroy</code>:</p> <ul> <li>Purpose: This command destroys all resources managed by our Terraform configuration. It is useful for cleaning up resources when they are no longer needed.</li> <li>When to Run: We use this command when we want to completely remove our infrastructure. It will ask for confirmation before proceeding.</li> </ul> </li> </ol>"},{"location":"devops/terraform/#terraform-state-tfstate","title":"Terraform State (<code>tfstate</code>)","text":"<ul> <li> <p>What It Is: Terraform's state file (<code>terraform.tfstate</code>) is a JSON file that keeps track of the infrastructure resources managed by Terraform. It acts as a snapshot of the deployed infrastructure, storing information about the current state of resources, including IDs, attributes, and metadata.</p> </li> <li> <p>Purpose: The state file is essential for Terraform to understand what has been created, modified, or destroyed. When we run <code>terraform plan</code> or <code>terraform apply</code>, Terraform compares the current state in the <code>tfstate</code> file with the desired state defined in your configuration file to determine the necessary actions.</p> </li> <li> <p>Storage: The state file is stored locally by default, but it can (and should) be stored remotely in a secure backend (e.g., Azure Blob Storage, AWS S3) to facilitate collaboration and ensure consistency across multiple team members.</p> </li> </ul>"},{"location":"devops/terraform/#terraform-diff","title":"Terraform Diff","text":"<ul> <li> <p>What It Is: The diff in Terraform refers to the difference between the current state of our infrastructure (as recorded in the <code>tfstate</code> file) and the desired state defined in our Terraform configuration.</p> </li> <li> <p>Purpose: The diff is generated when we run <code>terraform plan</code>. It shows a summary of what will change if we run <code>terraform apply</code>. This includes resources to be created, modified, or destroyed, marked with <code>+</code>, <code>~</code>, and <code>-</code> respectively in the output.</p> </li> <li> <p>Importance: Reviewing the diff before applying changes is critical to ensure that the planned modifications align with your expectations. It helps avoid unintentional changes to our infrastructure.</p> </li> </ul> <p>By running these Terraform commands and understanding the role of the <code>tfstate</code> file and the diff, we can effectively manage our infrastructure changes, ensuring they are applied safely and accurately.</p>"},{"location":"system-architecture/overview/","title":"Overview","text":"<p>The system architecture diagram illustrates how different components of the DigiStokvel ecosystem interact to handle user requests and manage stokvel operations.</p> <p></p> <p>Here's a breakdown of the architecture and the flow of interactions:</p>"},{"location":"system-architecture/overview/#components-overview","title":"Components Overview","text":"<p>User:</p> <ul> <li>Represents the end user interacting with the DigiStokvel system. Users primarily engage with the system via WhatsApp.</li> </ul> <p>Internal Control:</p> <ul> <li>WhatsApp: Users send and receive messages via WhatsApp. This serves as the primary interface for internal control, where users can perform actions like making contributions, requesting payouts, or querying stokvel information.</li> <li>Twilio: This service routes messages between WhatsApp and the backend systems. It helps manage the communication channel, ensuring that requests from users are properly routed and responses are sent back.</li> </ul> <p>External Control:</p> <ul> <li>Flask Template: Users may need to interact with a web-based form or interface outside the WhatsApp environment. This template is used when users need to perform actions that require leaving the WhatsApp system, such as filling out detailed forms or accessing specific web functionalities.</li> </ul> <p>Cloud Environment (DigiStokvel EcoSystem):</p> <ul> <li>Flask App: This serves as the core backend application. It handles incoming requests from the user, processes them, and interacts with the SQLite database. The Flask app manages the main business logic of the DigiStokvel system.</li> <li>Express App: Responsible for handling specific actions such as creating grants, processing incoming/outgoing payments, and generating quotes. It communicates with the Flask app via HTTP requests, responding to requests and sending back the necessary information or actions.</li> <li>Function App: Operates as a serverless function that can be triggered by specific events or run on a schedule (e.g., via cron jobs). It handles background tasks and automation, such as running the daily cron job to process any scheduled payments or contributions. It communicates with the Flask app for processing these tasks.</li> </ul> <p>Database (SQLite):</p> <ul> <li>The SQLite database stores all the information related to users, stokvels, transactions, contributions, and other system data. The Flask app interacts with this database to fetch and update information as required.</li> </ul>"},{"location":"system-architecture/overview/#flow-of-interactions","title":"Flow of Interactions","text":"<p>Internal Control Flow:</p> <ul> <li>Users interact with the system via WhatsApp, sending requests (e.g., to contribute to a stokvel or request information).</li> <li>Twilio acts as the gateway, routing the requests to the Flask App.</li> <li>The Flask App processes the request, interacts with the SQLite Database to fetch or update data, and sends the appropriate response back through Twilio, which then returns the response to the user via WhatsApp.</li> <li>This ensures that users remain within the WhatsApp environment for these interactions, keeping them in \"internal control.\"</li> </ul> <p>External Control Flow:</p> <ul> <li>If the user needs to perform an action that requires a more complex interface (e.g., filling out a form), they are directed to the Flask Template, which provides a web-based interface. This action falls under \"external control\" because the user must leave the WhatsApp environment.</li> <li>Once the required action is completed, the user can return to the WhatsApp interface to continue engaging with the system.</li> </ul> <p>Background Processing:</p> <ul> <li>The Function App manages tasks that need to be executed automatically, such as processing contributions and payouts. A cron job runs every day, triggering the Function App to check for any scheduled payments.</li> <li>The Function App sends requests to the Flask App to execute these payments, which may involve creating records in the SQLite Database and communicating with the Express App to handle payment actions.</li> <li>The Express App executes specific actions like creating grants or processing payments based on requests from the Flask App and sends the appropriate response back.</li> </ul> <p>The architecture effectively integrates multiple components, providing seamless user interactions via WhatsApp, automating regular tasks through cron jobs, and managing business logic and data processing through Flask and Express applications. The division between internal and external control helps streamline the user experience, ensuring smooth interactions within the WhatsApp environment while supporting external activities when necessary. The automated Function App ensures that daily operations like payments and contributions are processed without manual intervention, enhancing system efficiency.</p>"}]}